
> crypto-analytics-dashboard@0.1.0 dev
> nodemon --exec "npx tsx server.ts" --watch server.ts --watch src --ext ts,tsx,js,jsx 2>&1 | tee dev.log

[33m[nodemon] 3.1.10[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching path(s): server.ts src/**/*[39m
[33m[nodemon] watching extensions: ts,tsx,js,jsx[39m
[32m[nodemon] starting `npx tsx server.ts`[39m
ðŸ”„ Smart Rate Limiter started processing queues
ðŸš€ Initializing AI/ML systems...
Initializing AI/ML anomaly detection system...
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
Starting AI/ML model training...
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? LIMIT ? OFFSET ?
Training models for cryptocurrency bitcoin
Training statistical model for bitcoin
Training correlation model for bitcoin
Training models for cryptocurrency ethereum
Training statistical model for ethereum
Training correlation model for ethereum
Training models for cryptocurrency binancecoin
Training statistical model for binancecoin
Training correlation model for binancecoin
Training models for cryptocurrency solana
Training statistical model for solana
Training correlation model for solana
AI/ML model training completed
AI/ML anomaly detection system initialized successfully
âœ… Anomaly detection system initialized
âœ… Data providers initialized
> Ready on http://0.0.0.0:3000
> Socket.IO server running at ws://0.0.0.0:3000/api/socketio
ðŸš€ Starting data collector...
ðŸš€ Starting scheduled data collection...
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸ“Š Price data collection started (every 5 minutes)
ðŸ“ˆ Technical data collection started (every 15 minutes)
â›“ï¸ On-chain data collection started (every 60 minutes)
ðŸ˜Š Sentiment data collection started (every 90 minutes)
ðŸ“Š Derivative data collection started (every 30 minutes)
ðŸ“Š Volume data collection started (every 60 minutes)
ðŸ¤– AI analysis started (every 30 minutes)
ðŸ’¼ Token Terminal data collection started (every 360 minutes)
ðŸŒ Artemis data collection started (every 120 minutes)
ðŸ”¬ Glassnode data collection started (every 720 minutes)
ðŸš¨ Anomaly detection started (every 15 minutes)
ðŸ”„ Running initial data collection...
ðŸš€ Executing alternative request (priority 2)
ðŸ’¼ Starting Token Terminal data collection...
ðŸŒ Starting Artemis data collection...
ðŸ”¬ Starting Glassnode data collection...
ðŸš¨ Starting anomaly detection...
ðŸš€ Executing internal request (priority 2)
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced on-chain data for bitcoin
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced derivative data for bitcoin
ðŸš€ Executing coingecko request (priority 2)
ðŸš€ Executing ai request (priority 4)
Error in Token Terminal data collection: Error [PrismaClientValidationError]: 
Invalid `prisma.cryptocurrency.findMany()` invocation:

{
  where: {
    isActive: true
  },
  orderBy: {
    marketCap: "desc",
    ~~~~~~~~~
?   id?: SortOrder,
?   symbol?: SortOrder,
?   name?: SortOrder,
?   coinGeckoId?: SortOrder,
?   logo?: SortOrder | SortOrderInput,
?   rank?: SortOrder | SortOrderInput,
?   isActive?: SortOrder,
?   isDefault?: SortOrder,
?   addedBy?: SortOrder | SortOrderInput,
?   createdAt?: SortOrder,
?   updatedAt?: SortOrder,
?   priceHistory?: PriceHistoryOrderByRelationAggregateInput,
?   onChainMetrics?: OnChainMetricOrderByRelationAggregateInput,
?   technicalIndicators?: TechnicalIndicatorOrderByRelationAggregateInput,
?   sentimentMetrics?: SentimentMetricOrderByRelationAggregateInput,
?   derivativeMetrics?: DerivativeMetricOrderByRelationAggregateInput,
?   volumeHistory?: VolumeHistoryOrderByRelationAggregateInput,
?   watchlist?: WatchlistOrderByRelationAggregateInput,
?   portfolio?: PortfolioOrderByRelationAggregateInput,
?   alerts?: AlertOrderByRelationAggregateInput,
?   analysis?: AnalysisOrderByRelationAggregateInput,
?   analysisHistory?: AnalysisHistoryOrderByRelationAggregateInput,
?   dataCollection?: CoinDataCollectionOrderByWithRelationInput,
?   tvlMetrics?: TVLMetricOrderByRelationAggregateInput,
?   advancedTvlMetrics?: AdvancedTVLMetricOrderByRelationAggregateInput,
?   enhancedTvlMetrics?: EnhancedTVLMetricOrderByRelationAggregateInput,
?   stakingMetrics?: StakingMetricOrderByRelationAggregateInput,
?   addedByUser?: UserOrderByWithRelationInput
  },
  take: 20
}

Unknown argument `marketCap`. Available options are marked with ?.
    at async TokenTerminalDataProvider.collectDataForAllCryptocurrencies (src/lib/token-terminal-data-provider.ts:318:31)
    at async DataCollector.collectTokenTerminalData (src/lib/data-collector.ts:668:6)
    at async DataCollector.collectAllData (src/lib/data-collector.ts:809:4)
    at async DataCollector.startScheduledCollection (src/lib/data-collector.ts:197:6) {
  clientVersion: '6.13.0'
}
âœ… Token Terminal data collection completed
Error in Artemis data collection: Error [PrismaClientValidationError]: 
Invalid `prisma.cryptocurrency.findMany()` invocation:

{
  where: {
    isActive: true
  },
  orderBy: {
    marketCap: "desc",
    ~~~~~~~~~
?   id?: SortOrder,
?   symbol?: SortOrder,
?   name?: SortOrder,
?   coinGeckoId?: SortOrder,
?   logo?: SortOrder | SortOrderInput,
?   rank?: SortOrder | SortOrderInput,
?   isActive?: SortOrder,
?   isDefault?: SortOrder,
?   addedBy?: SortOrder | SortOrderInput,
?   createdAt?: SortOrder,
?   updatedAt?: SortOrder,
?   priceHistory?: PriceHistoryOrderByRelationAggregateInput,
?   onChainMetrics?: OnChainMetricOrderByRelationAggregateInput,
?   technicalIndicators?: TechnicalIndicatorOrderByRelationAggregateInput,
?   sentimentMetrics?: SentimentMetricOrderByRelationAggregateInput,
?   derivativeMetrics?: DerivativeMetricOrderByRelationAggregateInput,
?   volumeHistory?: VolumeHistoryOrderByRelationAggregateInput,
?   watchlist?: WatchlistOrderByRelationAggregateInput,
?   portfolio?: PortfolioOrderByRelationAggregateInput,
?   alerts?: AlertOrderByRelationAggregateInput,
?   analysis?: AnalysisOrderByRelationAggregateInput,
?   analysisHistory?: AnalysisHistoryOrderByRelationAggregateInput,
?   dataCollection?: CoinDataCollectionOrderByWithRelationInput,
?   tvlMetrics?: TVLMetricOrderByRelationAggregateInput,
?   advancedTvlMetrics?: AdvancedTVLMetricOrderByRelationAggregateInput,
?   enhancedTvlMetrics?: EnhancedTVLMetricOrderByRelationAggregateInput,
?   stakingMetrics?: StakingMetricOrderByRelationAggregateInput,
?   addedByUser?: UserOrderByWithRelationInput
  },
  take: 15
}

Unknown argument `marketCap`. Available options are marked with ?.
    at async ArtemisDataProvider.collectDataForAllCryptocurrencies (src/lib/artemis-data-provider.ts:479:31)
    at async DataCollector.collectArtemisData (src/lib/data-collector.ts:684:6)
    at async DataCollector.collectAllData (src/lib/data-collector.ts:809:4)
    at async DataCollector.startScheduledCollection (src/lib/data-collector.ts:197:6) {
  clientVersion: '6.13.0'
}
âœ… Artemis data collection completed
Error in Glassnode data collection: Error [PrismaClientValidationError]: 
Invalid `prisma.cryptocurrency.findMany()` invocation:

{
  where: {
    isActive: true
  },
  orderBy: {
    marketCap: "desc",
    ~~~~~~~~~
?   id?: SortOrder,
?   symbol?: SortOrder,
?   name?: SortOrder,
?   coinGeckoId?: SortOrder,
?   logo?: SortOrder | SortOrderInput,
?   rank?: SortOrder | SortOrderInput,
?   isActive?: SortOrder,
?   isDefault?: SortOrder,
?   addedBy?: SortOrder | SortOrderInput,
?   createdAt?: SortOrder,
?   updatedAt?: SortOrder,
?   priceHistory?: PriceHistoryOrderByRelationAggregateInput,
?   onChainMetrics?: OnChainMetricOrderByRelationAggregateInput,
?   technicalIndicators?: TechnicalIndicatorOrderByRelationAggregateInput,
?   sentimentMetrics?: SentimentMetricOrderByRelationAggregateInput,
?   derivativeMetrics?: DerivativeMetricOrderByRelationAggregateInput,
?   volumeHistory?: VolumeHistoryOrderByRelationAggregateInput,
?   watchlist?: WatchlistOrderByRelationAggregateInput,
?   portfolio?: PortfolioOrderByRelationAggregateInput,
?   alerts?: AlertOrderByRelationAggregateInput,
?   analysis?: AnalysisOrderByRelationAggregateInput,
?   analysisHistory?: AnalysisHistoryOrderByRelationAggregateInput,
?   dataCollection?: CoinDataCollectionOrderByWithRelationInput,
?   tvlMetrics?: TVLMetricOrderByRelationAggregateInput,
?   advancedTvlMetrics?: AdvancedTVLMetricOrderByRelationAggregateInput,
?   enhancedTvlMetrics?: EnhancedTVLMetricOrderByRelationAggregateInput,
?   stakingMetrics?: StakingMetricOrderByRelationAggregateInput,
?   addedByUser?: UserOrderByWithRelationInput
  },
  take: 10
}

Unknown argument `marketCap`. Available options are marked with ?.
    at async GlassnodeDataProvider.collectDataForAllCryptocurrencies (src/lib/glassnode-data-provider.ts:751:31)
    at async DataCollector.collectGlassnodeData (src/lib/data-collector.ts:700:6)
    at async DataCollector.collectAllData (src/lib/data-collector.ts:809:4)
    at async DataCollector.startScheduledCollection (src/lib/data-collector.ts:197:6) {
  clientVersion: '6.13.0'
}
âœ… Glassnode data collection completed
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` <= ?) ORDER BY `main`.`volume_history`.`timestamp` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
ðŸš€ Executing coingecko request (priority 1)
ðŸ“Š Volume data collected for BTC
â³ Queued coingecko request (priority 2) - Queue size: 1
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ“ˆ Technical data collected for BTC (confidence: 90.0%)
ðŸš€ Executing internal request (priority 2)
ðŸ” Attempting to get real on-chain data for bitcoin
ðŸ” Getting on-chain data for bitcoin
ðŸ” Attempting to get real derivative data for bitcoin
âš ï¸ No real derivative data available for bitcoin
âš ï¸ Derivative data validation failed for BTC: Invalid derivative data format
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced derivative data for ethereum
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
ðŸ“ˆ Technical data collected for ETH (confidence: 90.0%)
ðŸš€ Executing internal request (priority 2)
âœ… Generated on-chain data for bitcoin: {
  activeAddresses: 559540,
  newAddresses: 83931,
  transactionVolume: 29384331558
}
âœ… Real on-chain data found for bitcoin
âœ… Enhanced on-chain data collected for bitcoin
ðŸ” Attempting to get real derivative data for ethereum
âš ï¸ No real derivative data available for ethereum
âš ï¸ Derivative data validation failed for ETH: Invalid derivative data format
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced derivative data for binancecoin
âœ… Anomaly detection completed
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
ðŸ’¾ Saved on-chain metrics for bitcoin: {
  activeAddresses: 559540,
  newAddresses: 94978,
  transactionVolume: 29384331558
}
â›“ï¸ On-chain data collected for BTC (confidence: 85.0%)
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced on-chain data for ethereum
prisma:query INSERT INTO `main`.`on_chain_metrics` (`id`, `cryptoId`, `timestamp`, `mvrv`, `nupl`, `sopr`, `activeAddresses`, `newAddresses`, `exchangeInflow`, `exchangeOutflow`, `transactionVolume`, `whaleHoldingsPercentage`, `retailHoldingsPercentage`, `exchangeHoldingsPercentage`) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `mvrv` AS `mvrv`, `nupl` AS `nupl`, `sopr` AS `sopr`, `activeAddresses` AS `activeAddresses`, `newAddresses` AS `newAddresses`, `exchangeInflow` AS `exchangeInflow`, `exchangeOutflow` AS `exchangeOutflow`, `transactionVolume` AS `transactionVolume`, `supplyDistribution` AS `supplyDistribution`, `whaleHoldingsPercentage` AS `whaleHoldingsPercentage`, `retailHoldingsPercentage` AS `retailHoldingsPercentage`, `exchangeHoldingsPercentage` AS `exchangeHoldingsPercentage`
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
ðŸ” Attempting to get real derivative data for binancecoin
âš ï¸ No real derivative data available for binancecoin
âš ï¸ Derivative data validation failed for BNB: Invalid derivative data format
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced derivative data for solana
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ” Attempting to get real on-chain data for ethereum
ðŸ” Getting on-chain data for ethereum
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ” Attempting to get real derivative data for solana
âš ï¸ No real derivative data available for solana
âš ï¸ Derivative data validation failed for SOL: Invalid derivative data format
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Generated on-chain data for ethereum: {
  activeAddresses: 737933,
  newAddresses: 110689,
  transactionVolume: 12000517302
}
âœ… Real on-chain data found for ethereum
âœ… Enhanced on-chain data collected for ethereum
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
ðŸ“ˆ Technical data collected for BNB (confidence: 90.0%)
ðŸš€ Executing internal request (priority 2)
prisma:query INSERT INTO `main`.`on_chain_metrics` (`id`, `cryptoId`, `timestamp`, `mvrv`, `nupl`, `sopr`, `activeAddresses`, `newAddresses`, `exchangeInflow`, `exchangeOutflow`, `transactionVolume`, `whaleHoldingsPercentage`, `retailHoldingsPercentage`, `exchangeHoldingsPercentage`) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `mvrv` AS `mvrv`, `nupl` AS `nupl`, `sopr` AS `sopr`, `activeAddresses` AS `activeAddresses`, `newAddresses` AS `newAddresses`, `exchangeInflow` AS `exchangeInflow`, `exchangeOutflow` AS `exchangeOutflow`, `transactionVolume` AS `transactionVolume`, `supplyDistribution` AS `supplyDistribution`, `whaleHoldingsPercentage` AS `whaleHoldingsPercentage`, `retailHoldingsPercentage` AS `retailHoldingsPercentage`, `exchangeHoldingsPercentage` AS `exchangeHoldingsPercentage`
ðŸ’¾ Saved on-chain metrics for ethereum: {
  activeAddresses: 737933,
  newAddresses: 109347,
  transactionVolume: 12000517302
}
â›“ï¸ On-chain data collected for ETH (confidence: 85.0%)
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced on-chain data for binancecoin
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ” Attempting to get real on-chain data for binancecoin
ðŸ” Getting on-chain data for binancecoin
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Generated on-chain data for binancecoin: {
  activeAddresses: 399752,
  newAddresses: 59962,
  transactionVolume: 727189158
}
âœ… Real on-chain data found for binancecoin
âœ… Enhanced on-chain data collected for binancecoin
ðŸ’¾ Saved on-chain metrics for binancecoin: {
  activeAddresses: 399752,
  newAddresses: 75006,
  transactionVolume: 727189158
}
â›“ï¸ On-chain data collected for BNB (confidence: 85.0%)
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced on-chain data for solana
prisma:query INSERT INTO `main`.`on_chain_metrics` (`id`, `cryptoId`, `timestamp`, `mvrv`, `nupl`, `sopr`, `activeAddresses`, `newAddresses`, `exchangeInflow`, `exchangeOutflow`, `transactionVolume`, `whaleHoldingsPercentage`, `retailHoldingsPercentage`, `exchangeHoldingsPercentage`) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `mvrv` AS `mvrv`, `nupl` AS `nupl`, `sopr` AS `sopr`, `activeAddresses` AS `activeAddresses`, `newAddresses` AS `newAddresses`, `exchangeInflow` AS `exchangeInflow`, `exchangeOutflow` AS `exchangeOutflow`, `transactionVolume` AS `transactionVolume`, `supplyDistribution` AS `supplyDistribution`, `whaleHoldingsPercentage` AS `whaleHoldingsPercentage`, `retailHoldingsPercentage` AS `retailHoldingsPercentage`, `exchangeHoldingsPercentage` AS `exchangeHoldingsPercentage`
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
ðŸ“ˆ Technical data collected for SOL (confidence: 90.0%)
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ” Attempting to get real on-chain data for solana
ðŸ” Getting on-chain data for solana
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Generated on-chain data for solana: {
  activeAddresses: 531973,
  newAddresses: 79795,
  transactionVolume: 1473033044
}
âœ… Real on-chain data found for solana
âœ… Enhanced on-chain data collected for solana
âš ï¸ On-chain data validation failed for SOL: Active addresses out of expected range
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BTC: $113,411
â³ Queued coingecko request (priority 1) - Queue size: 2
prisma:query INSERT INTO `main`.`sentiment_metrics` (`id`, `timestamp`, `fearGreedIndex`, `socialSentiment`, `googleTrends`, `newsSentiment`) VALUES (?,?,?,?,?,?) RETURNING `id` AS `id`, `timestamp` AS `timestamp`, `fearGreedIndex` AS `fearGreedIndex`, `socialSentiment` AS `socialSentiment`, `googleTrends` AS `googleTrends`, `newsSentiment` AS `newsSentiment`
ðŸ˜Š Sentiment data collected: Fear & Greed 44
 â—‹ Compiling / ...
âŒ Error saving analysis history: Error [PrismaClientValidationError]: 
Invalid `prisma.analysisHistory.create()` invocation:

{
  data: {
    cryptoId: "bitcoin",
    signal: "HOLD",
    confidence: 0.5,
    reasoning: "Market conditions are neutral",
    riskLevel: "MEDIUM",
    aiModel: "z-ai-web-dev-sdk-v1",
    metricsData: "{\"timestamp\":\"2025-08-20T13:29:14.094Z\",\"analysisType\":\"automated\",\"version\":\"1.0\"}",
+   coinId: String
  }
}

Argument `coinId` is missing.
    at async DataCollector.saveAnalysisHistory (src/lib/data-collector.ts:941:6)
    at async (src/lib/data-collector.ts:775:10)
    at async SmartRateLimiter.executeTask (src/lib/rate-limiter.ts:122:21)
    at async DataCollector.runAIAnalysis (src/lib/data-collector.ts:773:8)
    at async DataCollector.collectAllData (src/lib/data-collector.ts:809:4)
    at async DataCollector.startScheduledCollection (src/lib/data-collector.ts:197:6) {
  clientVersion: '6.13.0'
}
ðŸ¤– AI analysis completed for BTC: HOLD (50.0% confidence)
ðŸš€ Executing ai request (priority 4)
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 âœ“ Compiled / in 7.8s (1574 modules)
ðŸš€ Initializing Performance Optimization Module...
ðŸš€ Initializing Performance Optimization Service...
âœ… Redis cache connected
âœ… Multi-Layer Caching Strategy initialized
ðŸ”„ Load Testing Service initialized
prisma:info Starting a sqlite pool with 9 connections.
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SET pool_size = 20;
        SET max_connections = 100;
        SET shared_buffers = '256MB';
        SET effective_cache_size = '1GB';
        SET maintenance_work_mem = '64MB';
        SET checkpoint_completion_target = 0.9;
        SET wal_buffers = '16MB';
        SET default_statistics_target = 100;
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Performance dashboard initialized
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
âš ï¸ Connection pooling setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
    at async DatabaseOptimizationService.setupConnectionPooling (src/lib/performance/database-optimization.ts:92:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:76:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  90 |     try {
  91 |       // Configure connection pool settings
> 92 |       await this.prisma.$executeRaw`
     |      ^
  93 |         SET pool_size = 20;
  94 |         SET max_connections = 100;
  95 |         SET shared_buffers = '256MB'; {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:query 
        SET enable_nestloop = ON;
        SET enable_hashjoin = ON;
        SET enable_mergejoin = ON;
        SET enable_indexscan = ON;
        SET enable_bitmapscan = ON;
        SET effective_io_concurrency = 2;
        SET random_page_cost = 1.1;
        SET seq_page_cost = 1.0;
      
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
âš ï¸ Query optimization setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
    at async DatabaseOptimizationService.setupQueryOptimization (src/lib/performance/database-optimization.ts:112:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:77:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  110 |     try {
  111 |       // Enable query optimization features
> 112 |       await this.prisma.$executeRaw`
      |      ^
  113 |         SET enable_nestloop = ON;
  114 |         SET enable_hashjoin = ON;
  115 |         SET enable_mergejoin = ON; {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
 GET / 200 in 8800ms
prisma:query 
        CREATE INDEX IF NOT EXISTS idx_crypto_symbol_active 
        ON "main"."cryptocurrencies" (symbol, is_active);
        
        CREATE INDEX IF NOT EXISTS idx_crypto_created_at 
        ON "main"."cryptocurrencies" (created_at);
        
        CREATE INDEX IF NOT EXISTS idx_price_history_crypto_timestamp 
        ON "main"."price_history" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_price_history_timestamp 
        ON "main"."price_history" (timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_onchain_crypto_timestamp 
        ON "main"."on_chain_metrics" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_technical_crypto_timestamp 
        ON "main"."technical_indicators" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_sentiment_crypto_timestamp 
        ON "main"."sentiment_data" (crypto_id, timestamp DESC);
      
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near ".": syntax error`
âš ï¸ Index optimization setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near ".": syntax error`
    at async DatabaseOptimizationService.setupIndexOptimization (src/lib/performance/database-optimization.ts:132:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:78:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  130 |     try {
  131 |       // Create performance monitoring indexes if they don't exist
> 132 |       await this.prisma.$executeRaw`
      |      ^
  133 |         CREATE INDEX IF NOT EXISTS idx_crypto_symbol_active 
  134 |         ON "main"."cryptocurrencies" (symbol, is_active);
  135 |          {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:query 
        SELECT * FROM pg_extension WHERE extname = 'pg_partman'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_extension`
âš ï¸ Partitioning setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_extension`
    at async DatabaseOptimizationService.setupPartitioning (src/lib/performance/database-optimization.ts:164:27)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:79:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  162 |     try {
  163 |       // Check if partitioning extension is available
> 164 |       const partitionExt = await this.prisma.$queryRaw`
      |                           ^
  165 |         SELECT * FROM pg_extension WHERE extname = 'pg_partman'
  166 |       `;
  167 |        {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Database Optimization Service initialized successfully
âœ… Database optimization initialized
âœ… Caching strategy initialized
ðŸ”„ Initializing Cache Warming Service...
ðŸ“… Scheduled warm-market-data every 5 minutes
ðŸ“… Scheduled warm-crypto-metrics every 10 minutes
ðŸ“… Scheduled warm-analysis-data every 15 minutes
ðŸ“… Scheduled warm-sentiment-data every 30 minutes
âœ… Cache warming tasks scheduled
ðŸ”„ Running initial cache warming...
ðŸ”„ Warming market data cache...
ðŸ”„ Warming crypto metrics cache...
ðŸ”„ Warming analysis data cache...
ðŸ”„ Warming sentiment data cache...
âŒ Failed to get sentiment data: TypeError: Cannot read properties of undefined (reading 'findMany')
    at CacheWarmingService.getSentimentData (src/lib/performance/cache-warming.ts:375:51)
    at CacheWarmingService.warmSentimentData (src/lib/performance/cache-warming.ts:237:39)
    at CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:119:13)
    at CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:17)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  373 |   private async getSentimentData(): Promise<any[]> {
  374 |     try {
> 375 |       const sentimentData = await db.sentimentData.findMany({
      |                                                   ^
  376 |         where: {
  377 |           timestamp: {
  378 |             gte: new Date(Date.now() - 6 * 60 * 60 * 1000), // Last 6 hours
âŒ Failed to get crypto metrics for binancecoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for bitcoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for ethereum: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for solana: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âœ… Cache warming completed for 4 keys
âœ… Crypto metrics cache warmed for 4 cryptocurrencies
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`analysis_history`.`id`, `main`.`analysis_history`.`cryptoId`, `main`.`analysis_history`.`coinId`, `main`.`analysis_history`.`signal`, `main`.`analysis_history`.`confidence`, `main`.`analysis_history`.`reasoning`, `main`.`analysis_history`.`riskLevel`, `main`.`analysis_history`.`aiModel`, `main`.`analysis_history`.`analysisType`, `main`.`analysis_history`.`analysisData`, `main`.`analysis_history`.`metricsData`, `main`.`analysis_history`.`timestamp` FROM `main`.`analysis_history` WHERE `main`.`analysis_history`.`timestamp` >= ? ORDER BY `main`.`analysis_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
âœ… Initial cache warming completed
âœ… Cache Warming Service initialized successfully
âœ… Cache warming initialized
ðŸ”„ Initializing Performance Monitoring Service...
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Performance dashboard initialized
âœ… Metrics collection started
âœ… Performance Monitoring Service initialized successfully
âœ… Performance monitoring initialized
âœ… Load testing initialized
âœ… All components initialized
ðŸ“… Scheduled database-optimization every 60 minutes
ðŸ“… Scheduled database-health-check every 5 minutes
âœ… Cache warming scheduled
âœ… Performance monitoring scheduled
ðŸ“… Scheduled health-check every 5 minutes
âœ… Optimization tasks scheduled
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: HEALTHY
âœ… Performance Optimization Service initialized successfully
âœ… Performance Optimization Module initialized successfully
âŒ Error saving analysis history: Error [PrismaClientValidationError]: 
Invalid `prisma.analysisHistory.create()` invocation:

{
  data: {
    cryptoId: "ethereum",
    signal: "HOLD",
    confidence: 0.5,
    reasoning: "Market conditions are neutral",
    riskLevel: "MEDIUM",
    aiModel: "z-ai-web-dev-sdk-v1",
    metricsData: "{\"timestamp\":\"2025-08-20T13:29:22.564Z\",\"analysisType\":\"automated\",\"version\":\"1.0\"}",
+   coinId: String
  }
}

Argument `coinId` is missing.
    at async DataCollector.saveAnalysisHistory (src/lib/data-collector.ts:941:6)
    at async (src/lib/data-collector.ts:775:10)
    at async SmartRateLimiter.executeTask (src/lib/rate-limiter.ts:122:21)
    at async DataCollector.runAIAnalysis (src/lib/data-collector.ts:773:8)
    at async DataCollector.collectAllData (src/lib/data-collector.ts:809:4)
    at async DataCollector.startScheduledCollection (src/lib/data-collector.ts:197:6) {
  clientVersion: '6.13.0'
}
ðŸ¤– AI analysis completed for ETH: HOLD (50.0% confidence)
ðŸš€ Executing ai request (priority 4)
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
âŒ Error saving analysis history: Error [PrismaClientValidationError]: 
Invalid `prisma.analysisHistory.create()` invocation:

{
  data: {
    cryptoId: "binancecoin",
    signal: "HOLD",
    confidence: 0.5,
    reasoning: "Market conditions are neutral",
    riskLevel: "MEDIUM",
    aiModel: "z-ai-web-dev-sdk-v1",
    metricsData: "{\"timestamp\":\"2025-08-20T13:29:30.385Z\",\"analysisType\":\"automated\",\"version\":\"1.0\"}",
+   coinId: String
  }
}

Argument `coinId` is missing.
    at async DataCollector.saveAnalysisHistory (src/lib/data-collector.ts:941:6)
    at async (src/lib/data-collector.ts:775:10)
    at async SmartRateLimiter.executeTask (src/lib/rate-limiter.ts:122:21)
    at async DataCollector.runAIAnalysis (src/lib/data-collector.ts:773:8)
    at async DataCollector.collectAllData (src/lib/data-collector.ts:809:4)
    at async DataCollector.startScheduledCollection (src/lib/data-collector.ts:197:6) {
  clientVersion: '6.13.0'
}
ðŸ¤– AI analysis completed for BNB: HOLD (50.0% confidence)
ðŸš€ Executing ai request (priority 4)
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
âŒ Error collecting volume data: Error: Task coingecko_1755696545325_d86duxxob timed out after 30000ms
    at Timeout._onTimeout (src/lib/rate-limiter.ts:172:15)
âŒ Error collecting price data: Error: Task coingecko_1755696545447_yu1oprxem timed out after 30000ms
    at Timeout._onTimeout (src/lib/rate-limiter.ts:172:15)
âŒ Error saving analysis history: Error [PrismaClientValidationError]: 
Invalid `prisma.analysisHistory.create()` invocation:

{
  data: {
    cryptoId: "solana",
    signal: "HOLD",
    confidence: 0.5,
    reasoning: "Market conditions are neutral",
    riskLevel: "MEDIUM",
    aiModel: "z-ai-web-dev-sdk-v1",
    metricsData: "{\"timestamp\":\"2025-08-20T13:29:40.983Z\",\"analysisType\":\"automated\",\"version\":\"1.0\"}",
+   coinId: String
  }
}

Argument `coinId` is missing.
    at async DataCollector.saveAnalysisHistory (src/lib/data-collector.ts:941:6)
    at async (src/lib/data-collector.ts:775:10)
    at async SmartRateLimiter.executeTask (src/lib/rate-limiter.ts:122:21)
    at async DataCollector.runAIAnalysis (src/lib/data-collector.ts:773:8)
    at async DataCollector.collectAllData (src/lib/data-collector.ts:809:4)
    at async DataCollector.startScheduledCollection (src/lib/data-collector.ts:197:6) {
  clientVersion: '6.13.0'
}
ðŸ¤– AI analysis completed for SOL: HOLD (50.0% confidence)
âœ… Initial data collection completed
âœ… Scheduled data collection started successfully
ðŸ“… Data Collection Schedule:
   ðŸ’° Price Data: Every 5 minutes
   ðŸ“ˆ Technical Data: Every 15 minutes
   â›“ï¸ On-Chain Data: Every 60 minutes
   ðŸ˜Š Sentiment Data: Every 90 minutes
   ðŸ“Š Derivative Data: Every 30 minutes
   ðŸ“ˆ Volume Data: Every 60 minutes
   ðŸ¤– AI Analysis: Every 30 minutes
âœ… Data collector started successfully
ðŸš€ Initializing Performance Optimization Module...
âœ… Performance Optimization Module initialized successfully
 GET / 200 in 55ms
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 90.5%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing coingecko request (priority 1)
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BTC: $113,311
ðŸš€ Executing coingecko request (priority 1)
ðŸ”„ Warming market data cache...
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for ETH: $4,175.13
â³ Queued coingecko request (priority 1) - Queue size: 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸš€ Executing coingecko request (priority 1)
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BNB: $828.24
ðŸš€ Executing coingecko request (priority 1)
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for SOL: $180.39
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
 â—‹ Compiling /api/v2/blockchain/cashflow-metrics ...
 âœ“ Compiled /api/v2/blockchain/cashflow-metrics in 1304ms (741 modules)
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=ethereum&timeframe=24h 200 in 1441ms
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=ethereum&timeframe=24h 200 in 1517ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=ethereum 200 in 1549ms
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum&timeframe=24h 200 in 1869ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing coingecko request (priority 1)
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BTC: $113,464
ðŸš€ Executing coingecko request (priority 1)
ðŸ”„ Warming market data cache...
ðŸ”„ Warming crypto metrics cache...
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
âŒ Failed to get crypto metrics for binancecoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for bitcoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for ethereum: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for solana: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âœ… Cache warming completed for 4 keys
âœ… Crypto metrics cache warmed for 4 cryptocurrencies
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for ETH: $4,200.87
â³ Queued coingecko request (priority 1) - Queue size: 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸš€ Executing coingecko request (priority 1)
âŒ Error collecting price data: Error: Task coingecko_1755697175341_601k3cohk timed out after 30000ms
    at Timeout._onTimeout (src/lib/rate-limiter.ts:172:15)
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BNB: $828.68
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing internal request (priority 2)
ðŸš¨ Starting anomaly detection...
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing coingecko request (priority 1)
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ“ˆ Technical data collected for BTC (confidence: 90.0%)
ðŸš€ Executing internal request (priority 2)
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Anomaly detection completed
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
ðŸ“ˆ Technical data collected for ETH (confidence: 90.0%)
ðŸš€ Executing internal request (priority 2)
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
ðŸ“ˆ Technical data collected for BNB (confidence: 90.0%)
ðŸš€ Executing internal request (priority 2)
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
ðŸ“ˆ Technical data collected for SOL (confidence: 90.0%)
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BTC: $113,370
ðŸš€ Executing coingecko request (priority 1)
ðŸ”„ Warming analysis data cache...
ðŸ”„ Warming market data cache...
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT `main`.`analysis_history`.`id`, `main`.`analysis_history`.`cryptoId`, `main`.`analysis_history`.`coinId`, `main`.`analysis_history`.`signal`, `main`.`analysis_history`.`confidence`, `main`.`analysis_history`.`reasoning`, `main`.`analysis_history`.`riskLevel`, `main`.`analysis_history`.`aiModel`, `main`.`analysis_history`.`analysisType`, `main`.`analysis_history`.`analysisData`, `main`.`analysis_history`.`metricsData`, `main`.`analysis_history`.`timestamp` FROM `main`.`analysis_history` WHERE `main`.`analysis_history`.`timestamp` >= ? ORDER BY `main`.`analysis_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for ETH: $4,190.6
â³ Queued coingecko request (priority 1) - Queue size: 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸš€ Executing coingecko request (priority 1)
âŒ Error collecting price data: Error: Task coingecko_1755697475346_t0ksduody timed out after 30000ms
    at Timeout._onTimeout (src/lib/rate-limiter.ts:172:15)
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BNB: $828.87
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=ethereum 200 in 37ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=ethereum&timeframe=24h 200 in 42ms
 GET /api/v2/blockchain/cashflow-metrics?blockchain=ethereum&timeframe=24h 200 in 43ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum&timeframe=24h 200 in 1934ms
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 95.4%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 95.9%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing coingecko request (priority 1)
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BTC: $112,973
ðŸš€ Executing coingecko request (priority 1)
ðŸ”„ Warming market data cache...
ðŸ”„ Warming crypto metrics cache...
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT 1
âŒ Failed to get crypto metrics for binancecoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for bitcoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for ethereum: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for solana: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âœ… Cache warming completed for 4 keys
âœ… Crypto metrics cache warmed for 4 cryptocurrencies
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for ETH: $4,162.56
â³ Queued coingecko request (priority 1) - Queue size: 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 97.6%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸš€ Executing coingecko request (priority 1)
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BNB: $827.59
ðŸš€ Executing coingecko request (priority 1)
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for SOL: $180.3
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 92.4%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing coingecko request (priority 1)
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BTC: $112,710
ðŸš€ Executing coingecko request (priority 1)
ðŸ”„ Warming market data cache...
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for ETH: $4,135.3
â³ Queued coingecko request (priority 1) - Queue size: 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸš€ Executing coingecko request (priority 1)
âŒ Error collecting price data: Error: Task coingecko_1755698075336_azw4iyj8q timed out after 30000ms
    at Timeout._onTimeout (src/lib/rate-limiter.ts:172:15)
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BNB: $824.77
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
 âœ“ Compiled / in 462ms (917 modules)
ðŸš€ Initializing Performance Optimization Module...
ðŸš€ Initializing Performance Optimization Service...
ðŸš€ Initializing Performance Optimization Module...
ðŸš€ Initializing Performance Optimization Service...
âœ… Redis cache connected
âœ… Multi-Layer Caching Strategy initialized
ðŸ”„ Load Testing Service initialized
prisma:info Starting a sqlite pool with 9 connections.
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SET pool_size = 20;
        SET max_connections = 100;
        SET shared_buffers = '256MB';
        SET effective_cache_size = '1GB';
        SET maintenance_work_mem = '64MB';
        SET checkpoint_completion_target = 0.9;
        SET wal_buffers = '16MB';
        SET default_statistics_target = 100;
      
prisma:query 
        SET pool_size = 20;
        SET max_connections = 100;
        SET shared_buffers = '256MB';
        SET effective_cache_size = '1GB';
        SET maintenance_work_mem = '64MB';
        SET checkpoint_completion_target = 0.9;
        SET wal_buffers = '16MB';
        SET default_statistics_target = 100;
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Performance dashboard initialized
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
âš ï¸ Connection pooling setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
    at async DatabaseOptimizationService.setupConnectionPooling (src/lib/performance/database-optimization.ts:92:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:76:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  90 |     try {
  91 |       // Configure connection pool settings
> 92 |       await this.prisma.$executeRaw`
     |      ^
  93 |         SET pool_size = 20;
  94 |         SET max_connections = 100;
  95 |         SET shared_buffers = '256MB'; {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
âš ï¸ Connection pooling setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
    at async DatabaseOptimizationService.setupConnectionPooling (src/lib/performance/database-optimization.ts:92:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:76:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  90 |     try {
  91 |       // Configure connection pool settings
> 92 |       await this.prisma.$executeRaw`
     |      ^
  93 |         SET pool_size = 20;
  94 |         SET max_connections = 100;
  95 |         SET shared_buffers = '256MB'; {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:query 
        SET enable_nestloop = ON;
        SET enable_hashjoin = ON;
        SET enable_mergejoin = ON;
        SET enable_indexscan = ON;
        SET enable_bitmapscan = ON;
        SET effective_io_concurrency = 2;
        SET random_page_cost = 1.1;
        SET seq_page_cost = 1.0;
      
prisma:query 
        SET enable_nestloop = ON;
        SET enable_hashjoin = ON;
        SET enable_mergejoin = ON;
        SET enable_indexscan = ON;
        SET enable_bitmapscan = ON;
        SET effective_io_concurrency = 2;
        SET random_page_cost = 1.1;
        SET seq_page_cost = 1.0;
      
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
âš ï¸ Query optimization setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
    at async DatabaseOptimizationService.setupQueryOptimization (src/lib/performance/database-optimization.ts:112:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:77:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  110 |     try {
  111 |       // Enable query optimization features
> 112 |       await this.prisma.$executeRaw`
      |      ^
  113 |         SET enable_nestloop = ON;
  114 |         SET enable_hashjoin = ON;
  115 |         SET enable_mergejoin = ON; {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
âš ï¸ Query optimization setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
    at async DatabaseOptimizationService.setupQueryOptimization (src/lib/performance/database-optimization.ts:112:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:77:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  110 |     try {
  111 |       // Enable query optimization features
> 112 |       await this.prisma.$executeRaw`
      |      ^
  113 |         SET enable_nestloop = ON;
  114 |         SET enable_hashjoin = ON;
  115 |         SET enable_mergejoin = ON; {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
 GET / 200 in 1502ms
prisma:query 
        CREATE INDEX IF NOT EXISTS idx_crypto_symbol_active 
        ON "main"."cryptocurrencies" (symbol, is_active);
        
        CREATE INDEX IF NOT EXISTS idx_crypto_created_at 
        ON "main"."cryptocurrencies" (created_at);
        
        CREATE INDEX IF NOT EXISTS idx_price_history_crypto_timestamp 
        ON "main"."price_history" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_price_history_timestamp 
        ON "main"."price_history" (timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_onchain_crypto_timestamp 
        ON "main"."on_chain_metrics" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_technical_crypto_timestamp 
        ON "main"."technical_indicators" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_sentiment_crypto_timestamp 
        ON "main"."sentiment_data" (crypto_id, timestamp DESC);
      
prisma:query 
        CREATE INDEX IF NOT EXISTS idx_crypto_symbol_active 
        ON "main"."cryptocurrencies" (symbol, is_active);
        
        CREATE INDEX IF NOT EXISTS idx_crypto_created_at 
        ON "main"."cryptocurrencies" (created_at);
        
        CREATE INDEX IF NOT EXISTS idx_price_history_crypto_timestamp 
        ON "main"."price_history" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_price_history_timestamp 
        ON "main"."price_history" (timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_onchain_crypto_timestamp 
        ON "main"."on_chain_metrics" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_technical_crypto_timestamp 
        ON "main"."technical_indicators" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_sentiment_crypto_timestamp 
        ON "main"."sentiment_data" (crypto_id, timestamp DESC);
      
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near ".": syntax error`
âš ï¸ Index optimization setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near ".": syntax error`
    at async DatabaseOptimizationService.setupIndexOptimization (src/lib/performance/database-optimization.ts:132:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:78:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  130 |     try {
  131 |       // Create performance monitoring indexes if they don't exist
> 132 |       await this.prisma.$executeRaw`
      |      ^
  133 |         CREATE INDEX IF NOT EXISTS idx_crypto_symbol_active 
  134 |         ON "main"."cryptocurrencies" (symbol, is_active);
  135 |          {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near ".": syntax error`
âš ï¸ Index optimization setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near ".": syntax error`
    at async DatabaseOptimizationService.setupIndexOptimization (src/lib/performance/database-optimization.ts:132:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:78:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  130 |     try {
  131 |       // Create performance monitoring indexes if they don't exist
> 132 |       await this.prisma.$executeRaw`
      |      ^
  133 |         CREATE INDEX IF NOT EXISTS idx_crypto_symbol_active 
  134 |         ON "main"."cryptocurrencies" (symbol, is_active);
  135 |          {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:query 
        SELECT * FROM pg_extension WHERE extname = 'pg_partman'
      
prisma:query 
        SELECT * FROM pg_extension WHERE extname = 'pg_partman'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_extension`
âš ï¸ Partitioning setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_extension`
    at async DatabaseOptimizationService.setupPartitioning (src/lib/performance/database-optimization.ts:164:27)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:79:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  162 |     try {
  163 |       // Check if partitioning extension is available
> 164 |       const partitionExt = await this.prisma.$queryRaw`
      |                           ^
  165 |         SELECT * FROM pg_extension WHERE extname = 'pg_partman'
  166 |       `;
  167 |        {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Database Optimization Service initialized successfully
âœ… Database optimization initialized
âœ… Caching strategy initialized
ðŸ”„ Initializing Cache Warming Service...
ðŸ“… Scheduled warm-market-data every 5 minutes
ðŸ“… Scheduled warm-crypto-metrics every 10 minutes
ðŸ“… Scheduled warm-analysis-data every 15 minutes
ðŸ“… Scheduled warm-sentiment-data every 30 minutes
âœ… Cache warming tasks scheduled
ðŸ”„ Running initial cache warming...
ðŸ”„ Warming market data cache...
ðŸ”„ Warming crypto metrics cache...
ðŸ”„ Warming analysis data cache...
ðŸ”„ Warming sentiment data cache...
âŒ Failed to get sentiment data: TypeError: Cannot read properties of undefined (reading 'findMany')
    at CacheWarmingService.getSentimentData (src/lib/performance/cache-warming.ts:375:51)
    at CacheWarmingService.warmSentimentData (src/lib/performance/cache-warming.ts:237:39)
    at CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:119:13)
    at CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:17)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  373 |   private async getSentimentData(): Promise<any[]> {
  374 |     try {
> 375 |       const sentimentData = await db.sentimentData.findMany({
      |                                                   ^
  376 |         where: {
  377 |           timestamp: {
  378 |             gte: new Date(Date.now() - 6 * 60 * 60 * 1000), // Last 6 hours
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_extension`
âš ï¸ Partitioning setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_extension`
    at async DatabaseOptimizationService.setupPartitioning (src/lib/performance/database-optimization.ts:164:27)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:79:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  162 |     try {
  163 |       // Check if partitioning extension is available
> 164 |       const partitionExt = await this.prisma.$queryRaw`
      |                           ^
  165 |         SELECT * FROM pg_extension WHERE extname = 'pg_partman'
  166 |       `;
  167 |        {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Database Optimization Service initialized successfully
âœ… Database optimization initialized
âœ… Caching strategy initialized
ðŸ”„ Initializing Cache Warming Service...
ðŸ“… Scheduled warm-market-data every 5 minutes
ðŸ“… Scheduled warm-crypto-metrics every 10 minutes
ðŸ“… Scheduled warm-analysis-data every 15 minutes
ðŸ“… Scheduled warm-sentiment-data every 30 minutes
âœ… Cache warming tasks scheduled
ðŸ”„ Running initial cache warming...
ðŸ”„ Warming market data cache...
ðŸ”„ Warming crypto metrics cache...
ðŸ”„ Warming analysis data cache...
ðŸ”„ Warming sentiment data cache...
âŒ Failed to get sentiment data: TypeError: Cannot read properties of undefined (reading 'findMany')
    at CacheWarmingService.getSentimentData (src/lib/performance/cache-warming.ts:375:51)
    at CacheWarmingService.warmSentimentData (src/lib/performance/cache-warming.ts:237:39)
    at CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:119:13)
    at CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:17)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  373 |   private async getSentimentData(): Promise<any[]> {
  374 |     try {
> 375 |       const sentimentData = await db.sentimentData.findMany({
      |                                                   ^
  376 |         where: {
  377 |           timestamp: {
  378 |             gte: new Date(Date.now() - 6 * 60 * 60 * 1000), // Last 6 hours
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`analysis_history`.`id`, `main`.`analysis_history`.`cryptoId`, `main`.`analysis_history`.`coinId`, `main`.`analysis_history`.`signal`, `main`.`analysis_history`.`confidence`, `main`.`analysis_history`.`reasoning`, `main`.`analysis_history`.`riskLevel`, `main`.`analysis_history`.`aiModel`, `main`.`analysis_history`.`analysisType`, `main`.`analysis_history`.`analysisData`, `main`.`analysis_history`.`metricsData`, `main`.`analysis_history`.`timestamp` FROM `main`.`analysis_history` WHERE `main`.`analysis_history`.`timestamp` >= ? ORDER BY `main`.`analysis_history`.`timestamp` DESC LIMIT ? OFFSET ?
âŒ Failed to get crypto metrics for binancecoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for bitcoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for ethereum: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for solana: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âœ… Cache warming completed for 4 keys
âœ… Crypto metrics cache warmed for 4 cryptocurrencies
âŒ Failed to get crypto metrics for binancecoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for bitcoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for ethereum: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for solana: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âœ… Cache warming completed for 4 keys
âœ… Crypto metrics cache warmed for 4 cryptocurrencies
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`analysis_history`.`id`, `main`.`analysis_history`.`cryptoId`, `main`.`analysis_history`.`coinId`, `main`.`analysis_history`.`signal`, `main`.`analysis_history`.`confidence`, `main`.`analysis_history`.`reasoning`, `main`.`analysis_history`.`riskLevel`, `main`.`analysis_history`.`aiModel`, `main`.`analysis_history`.`analysisType`, `main`.`analysis_history`.`analysisData`, `main`.`analysis_history`.`metricsData`, `main`.`analysis_history`.`timestamp` FROM `main`.`analysis_history` WHERE `main`.`analysis_history`.`timestamp` >= ? ORDER BY `main`.`analysis_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
âœ… Initial cache warming completed
âœ… Cache Warming Service initialized successfully
âœ… Cache warming initialized
ðŸ”„ Initializing Performance Monitoring Service...
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
âœ… Initial cache warming completed
âœ… Cache Warming Service initialized successfully
âœ… Cache warming initialized
ðŸ”„ Initializing Performance Monitoring Service...
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Performance dashboard initialized
âœ… Metrics collection started
âœ… Performance Monitoring Service initialized successfully
âœ… Performance monitoring initialized
âœ… Load testing initialized
âœ… All components initialized
ðŸ“… Scheduled database-optimization every 60 minutes
ðŸ“… Scheduled database-health-check every 5 minutes
âœ… Cache warming scheduled
âœ… Performance monitoring scheduled
ðŸ“… Scheduled health-check every 5 minutes
âœ… Optimization tasks scheduled
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: HEALTHY
âœ… Performance Optimization Service initialized successfully
âœ… Performance Optimization Module initialized successfully
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Performance dashboard initialized
âœ… Performance Monitoring Service initialized successfully
âœ… Performance monitoring initialized
âœ… Load testing initialized
âœ… All components initialized
ðŸ“… Scheduled database-optimization every 60 minutes
ðŸ“… Scheduled database-health-check every 5 minutes
âœ… Cache warming scheduled
âœ… Performance monitoring scheduled
ðŸ“… Scheduled health-check every 5 minutes
âœ… Optimization tasks scheduled
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: HEALTHY
âœ… Performance Optimization Service initialized successfully
âœ… Performance Optimization Module initialized successfully
 GET / 200 in 1944ms
 âœ“ Compiled /favicon.ico in 303ms (933 modules)
 GET /favicon.ico 200 in 419ms
 âœ“ Compiled /api/v2/blockchain/market-overview in 179ms (937 modules)
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
 âœ“ Compiled in 610ms (658 modules)
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=bitcoin&timeframe=24h 200 in 1430ms
 GET /api/v2/blockchain/usage-metrics?blockchain=bitcoin&timeframe=24h 200 in 1439ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE 1=1 ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/enhanced-tvl?coinId=bitcoin&timeframe=24h 200 in 1436ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=bitcoin 200 in 1431ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
Error processing blockchain ethereum: TypeError: tvlService.getLatestTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-comparison/route.ts:47:44)
  45 |
  46 |         // Get TVL metrics
> 47 |         const tvlMetrics = await tvlService.getLatestTVLMetrics(crypto.id);
     |                                            ^
  48 |         
  49 |         // Get market data
  50 |         const priceData = await db.priceHistory.findFirst({
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
Error processing blockchain bitcoin: TypeError: tvlService.getLatestTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-comparison/route.ts:47:44)
  45 |
  46 |         // Get TVL metrics
> 47 |         const tvlMetrics = await tvlService.getLatestTVLMetrics(crypto.id);
     |                                            ^
  48 |         
  49 |         // Get market data
  50 |         const priceData = await db.priceHistory.findFirst({
Error processing blockchain solana: TypeError: tvlService.getLatestTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-comparison/route.ts:47:44)
  45 |
  46 |         // Get TVL metrics
> 47 |         const tvlMetrics = await tvlService.getLatestTVLMetrics(crypto.id);
     |                                            ^
  48 |         
  49 |         // Get market data
  50 |         const priceData = await db.priceHistory.findFirst({
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-comparison?blockchains=ethereum,bitcoin,solana,binance-smart-chain,polygon 200 in 1672ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=ethereum&timeframe=24h 200 in 37ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 â—‹ Compiling /api/v2/blockchain/ai-analysis ...
 âœ“ Compiled /api/v2/blockchain/ai-analysis in 568ms (1599 modules)
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
Fetching fresh enhanced TVL data for ethereum
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=ethereum&timeframe=24h 200 in 685ms
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=ethereum 200 in 663ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/ai-analysis?blockchain=bitcoin 200 in 766ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/ai-analysis?blockchain=ethereum 200 in 25ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=bitcoin&timeframe=24h 200 in 2667ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum&timeframe=24h 200 in 1402ms
Error fetching tvl-historical-global: Error: HTTP error! status: 404
    at TVLService.cachedFetch (src/lib/tvl-service.ts:71:14)
    at async TVLService.getGlobalTVL (src/lib/tvl-service.ts:164:50)
    at async EnhancedTVLMetricsService.calculateConcentrationRisk (src/lib/enhanced-tvl-metrics.ts:63:24)
    at async EnhancedTVLMetricsService.getEnhancedTVLMetrics (src/lib/enhanced-tvl-metrics.ts:195:50)
    at async EnhancedTVLMetricsService.storeEnhancedTVLMetrics (src/lib/enhanced-tvl-metrics.ts:243:22)
    at async GET (src/app/api/v2/blockchain/enhanced-tvl/route.ts:47:31)
  69 |       const response = await fetch(url);
  70 |       if (!response.ok) {
> 71 |         throw new Error(`HTTP error! status: ${response.status}`);
     |              ^
  72 |       }
  73 |       const data = await response.json();
  74 |       this.cache.set(key, { data, timestamp: now, ttl });
Error fetching global TVL: Error: HTTP error! status: 404
    at TVLService.cachedFetch (src/lib/tvl-service.ts:71:14)
    at async TVLService.getGlobalTVL (src/lib/tvl-service.ts:164:50)
    at async EnhancedTVLMetricsService.calculateConcentrationRisk (src/lib/enhanced-tvl-metrics.ts:63:24)
    at async EnhancedTVLMetricsService.getEnhancedTVLMetrics (src/lib/enhanced-tvl-metrics.ts:195:50)
    at async EnhancedTVLMetricsService.storeEnhancedTVLMetrics (src/lib/enhanced-tvl-metrics.ts:243:22)
    at async GET (src/app/api/v2/blockchain/enhanced-tvl/route.ts:47:31)
  69 |       const response = await fetch(url);
  70 |       if (!response.ok) {
> 71 |         throw new Error(`HTTP error! status: ${response.status}`);
     |              ^
  72 |       }
  73 |       const data = await response.json();
  74 |       this.cache.set(key, { data, timestamp: now, ttl });
Error calculating concentration risk: Error: HTTP error! status: 404
    at TVLService.cachedFetch (src/lib/tvl-service.ts:71:14)
    at async TVLService.getGlobalTVL (src/lib/tvl-service.ts:164:50)
    at async EnhancedTVLMetricsService.calculateConcentrationRisk (src/lib/enhanced-tvl-metrics.ts:63:24)
    at async EnhancedTVLMetricsService.getEnhancedTVLMetrics (src/lib/enhanced-tvl-metrics.ts:195:50)
    at async EnhancedTVLMetricsService.storeEnhancedTVLMetrics (src/lib/enhanced-tvl-metrics.ts:243:22)
    at async GET (src/app/api/v2/blockchain/enhanced-tvl/route.ts:47:31)
  69 |       const response = await fetch(url);
  70 |       if (!response.ok) {
> 71 |         throw new Error(`HTTP error! status: ${response.status}`);
     |              ^
  72 |       }
  73 |       const data = await response.json();
  74 |       this.cache.set(key, { data, timestamp: now, ttl });
Error calculating sustainability score: TypeError: protocolFees.filter is not a function
    at EnhancedTVLMetricsService.calculateSustainabilityScore (src/lib/enhanced-tvl-metrics.ts:140:42)
    at async EnhancedTVLMetricsService.getEnhancedTVLMetrics (src/lib/enhanced-tvl-metrics.ts:195:50)
    at async EnhancedTVLMetricsService.storeEnhancedTVLMetrics (src/lib/enhanced-tvl-metrics.ts:243:22)
    at async GET (src/app/api/v2/blockchain/enhanced-tvl/route.ts:47:31)
  138 |       // Get chain-specific data
  139 |       const chainName = this.mapCoinGeckoToChain(coinGeckoId);
> 140 |       const chainProtocols = protocolFees.filter(p => 
      |                                          ^
  141 |         p.name.toLowerCase().includes(chainName.toLowerCase()) ||
  142 |         this.isProtocolRelevantToChain(p.name, chainName)
  143 |       );
prisma:query INSERT INTO `main`.`enhanced_tvl_metrics` (`id`, `cryptoId`, `timestamp`, `concentrationRisk`, `herfindahlIndex`, `topProtocolDominance`, `top3ProtocolDominance`, `top5ProtocolDominance`, `protocolDiversity`, `concentrationLevel`, `concentrationTrend`, `sustainabilityScore`, `revenueStability`, `userGrowthRate`, `protocolHealth`, `ecosystemMaturity`, `riskAdjustedReturns`, `sustainabilityLevel`, `sustainabilityTrend`, `overallTVLHealth`, `recommendations`, `riskFactors`, `strengthFactors`, `confidence`, `lastUpdated`) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `concentrationRisk` AS `concentrationRisk`, `herfindahlIndex` AS `herfindahlIndex`, `topProtocolDominance` AS `topProtocolDominance`, `top3ProtocolDominance` AS `top3ProtocolDominance`, `top5ProtocolDominance` AS `top5ProtocolDominance`, `protocolDiversity` AS `protocolDiversity`, `concentrationLevel` AS `concentrationLevel`, `concentrationTrend` AS `concentrationTrend`, `sustainabilityScore` AS `sustainabilityScore`, `revenueStability` AS `revenueStability`, `userGrowthRate` AS `userGrowthRate`, `protocolHealth` AS `protocolHealth`, `ecosystemMaturity` AS `ecosystemMaturity`, `riskAdjustedReturns` AS `riskAdjustedReturns`, `sustainabilityLevel` AS `sustainabilityLevel`, `sustainabilityTrend` AS `sustainabilityTrend`, `overallTVLHealth` AS `overallTVLHealth`, `recommendations` AS `recommendations`, `riskFactors` AS `riskFactors`, `strengthFactors` AS `strengthFactors`, `confidence` AS `confidence`, `lastUpdated` AS `lastUpdated`
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE 1=1 ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/enhanced-tvl?coinId=ethereum&timeframe=24h 200 in 4333ms
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=ethereum&timeframe=24h 200 in 20ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=ethereum&timeframe=24h 200 in 641ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=ethereum 200 in 81ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum&timeframe=24h 200 in 463ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=ethereum&timeframe=24h 200 in 12ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=ethereum 200 in 14ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=ethereum&timeframe=24h 200 in 14ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum&timeframe=24h 200 in 435ms
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing internal request (priority 2)
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced derivative data for bitcoin
ðŸš€ Executing ai request (priority 4)
ðŸš¨ Starting anomaly detection...
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ” Attempting to get real derivative data for bitcoin
âš ï¸ No real derivative data available for bitcoin
âš ï¸ Derivative data validation failed for BTC: Invalid derivative data format
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced derivative data for ethereum
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing coingecko request (priority 1)
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ“ˆ Technical data collected for BTC (confidence: 90.0%)
ðŸš€ Executing internal request (priority 2)
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ” Attempting to get real derivative data for ethereum
âš ï¸ No real derivative data available for ethereum
âš ï¸ Derivative data validation failed for ETH: Invalid derivative data format
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced derivative data for binancecoin
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ“ˆ Technical data collected for ETH (confidence: 90.0%)
ðŸš€ Executing internal request (priority 2)
ðŸ” Attempting to get real derivative data for binancecoin
âš ï¸ No real derivative data available for binancecoin
âš ï¸ Derivative data validation failed for BNB: Invalid derivative data format
ðŸš€ Executing internal request (priority 3)
ðŸ” Fetching enhanced derivative data for solana
âœ… Anomaly detection completed
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
ðŸ” Attempting to get real derivative data for solana
âš ï¸ No real derivative data available for solana
âš ï¸ Derivative data validation failed for SOL: Invalid derivative data format
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
ðŸ“ˆ Technical data collected for BNB (confidence: 90.0%)
ðŸš€ Executing internal request (priority 2)
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query INSERT INTO `main`.`technical_indicators` (`id`, `cryptoId`, `timestamp`, `rsi`, `ma50`, `ma200`, `macd`, `bollingerUpper`, `bollingerLower`, `bollingerMiddle`) VALUES (?,?,?,?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `rsi` AS `rsi`, `ma50` AS `ma50`, `ma200` AS `ma200`, `macd` AS `macd`, `macdSignal` AS `macdSignal`, `bollingerUpper` AS `bollingerUpper`, `bollingerLower` AS `bollingerLower`, `bollingerMiddle` AS `bollingerMiddle`
ðŸ“ˆ Technical data collected for SOL (confidence: 90.0%)
ðŸ’° Price data collected for BTC: $112,804
ðŸš€ Executing coingecko request (priority 1)
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
âŒ Error saving analysis history: Error [PrismaClientValidationError]: 
Invalid `prisma.analysisHistory.create()` invocation:

{
  data: {
    cryptoId: "bitcoin",
    signal: "HOLD",
    confidence: 0.5,
    reasoning: "Market conditions are neutral",
    riskLevel: "MEDIUM",
    aiModel: "z-ai-web-dev-sdk-v1",
    metricsData: "{\"timestamp\":\"2025-08-20T13:59:14.821Z\",\"analysisType\":\"automated\",\"version\":\"1.0\"}",
+   coinId: String
  }
}

Argument `coinId` is missing.
    at async DataCollector.saveAnalysisHistory (src/lib/data-collector.ts:941:6)
    at async (src/lib/data-collector.ts:775:10)
    at async SmartRateLimiter.executeTask (src/lib/rate-limiter.ts:122:21)
    at async DataCollector.runAIAnalysis (src/lib/data-collector.ts:773:8)
    at async Timeout._onTimeout (src/lib/data-collector.ts:397:6) {
  clientVersion: '6.13.0'
}
ðŸ¤– AI analysis completed for BTC: HOLD (50.0% confidence)
ðŸš€ Executing ai request (priority 4)
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 90.6%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸ”„ Warming sentiment data cache...
âŒ Failed to get sentiment data: TypeError: Cannot read properties of undefined (reading 'findMany')
    at CacheWarmingService.getSentimentData (src/lib/performance/cache-warming.ts:375:51)
    at CacheWarmingService.warmSentimentData (src/lib/performance/cache-warming.ts:237:39)
    at eval (src/lib/performance/cache-warming.ts:78:93)
    at Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:14)
  373 |   private async getSentimentData(): Promise<any[]> {
  374 |     try {
> 375 |       const sentimentData = await db.sentimentData.findMany({
      |                                                   ^
  376 |         where: {
  377 |           timestamp: {
  378 |             gte: new Date(Date.now() - 6 * 60 * 60 * 1000), // Last 6 hours
ðŸ”„ Warming analysis data cache...
ðŸ”„ Warming crypto metrics cache...
ðŸ”„ Warming market data cache...
prisma:query SELECT 1
prisma:query SELECT `main`.`analysis_history`.`id`, `main`.`analysis_history`.`cryptoId`, `main`.`analysis_history`.`coinId`, `main`.`analysis_history`.`signal`, `main`.`analysis_history`.`confidence`, `main`.`analysis_history`.`reasoning`, `main`.`analysis_history`.`riskLevel`, `main`.`analysis_history`.`aiModel`, `main`.`analysis_history`.`analysisType`, `main`.`analysis_history`.`analysisData`, `main`.`analysis_history`.`metricsData`, `main`.`analysis_history`.`timestamp` FROM `main`.`analysis_history` WHERE `main`.`analysis_history`.`timestamp` >= ? ORDER BY `main`.`analysis_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
âŒ Failed to get crypto metrics for binancecoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for bitcoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for ethereum: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for solana: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âœ… Cache warming completed for 4 keys
âœ… Crypto metrics cache warmed for 4 cryptocurrencies
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=ethereum&timeframe=24h 200 in 14ms
âŒ Error saving analysis history: Error [PrismaClientValidationError]: 
Invalid `prisma.analysisHistory.create()` invocation:

{
  data: {
    cryptoId: "ethereum",
    signal: "HOLD",
    confidence: 0.5,
    reasoning: "Market conditions are neutral",
    riskLevel: "MEDIUM",
    aiModel: "z-ai-web-dev-sdk-v1",
    metricsData: "{\"timestamp\":\"2025-08-20T13:59:24.492Z\",\"analysisType\":\"automated\",\"version\":\"1.0\"}",
+   coinId: String
  }
}

Argument `coinId` is missing.
    at async DataCollector.saveAnalysisHistory (src/lib/data-collector.ts:941:6)
    at async (src/lib/data-collector.ts:775:10)
    at async SmartRateLimiter.executeTask (src/lib/rate-limiter.ts:122:21)
    at async DataCollector.runAIAnalysis (src/lib/data-collector.ts:773:8)
    at async Timeout._onTimeout (src/lib/data-collector.ts:397:6) {
  clientVersion: '6.13.0'
}
ðŸ¤– AI analysis completed for ETH: HOLD (50.0% confidence)
ðŸš€ Executing ai request (priority 4)
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=ethereum 200 in 12ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=ethereum&timeframe=24h 200 in 10ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum&timeframe=24h 200 in 353ms
âŒ Error saving analysis history: Error [PrismaClientValidationError]: 
Invalid `prisma.analysisHistory.create()` invocation:

{
  data: {
    cryptoId: "binancecoin",
    signal: "HOLD",
    confidence: 0.5,
    reasoning: "Market conditions are neutral",
    riskLevel: "MEDIUM",
    aiModel: "z-ai-web-dev-sdk-v1",
    metricsData: "{\"timestamp\":\"2025-08-20T13:59:31.980Z\",\"analysisType\":\"automated\",\"version\":\"1.0\"}",
+   coinId: String
  }
}

Argument `coinId` is missing.
    at async DataCollector.saveAnalysisHistory (src/lib/data-collector.ts:941:6)
    at async (src/lib/data-collector.ts:775:10)
    at async SmartRateLimiter.executeTask (src/lib/rate-limiter.ts:122:21)
    at async DataCollector.runAIAnalysis (src/lib/data-collector.ts:773:8)
    at async Timeout._onTimeout (src/lib/data-collector.ts:397:6) {
  clientVersion: '6.13.0'
}
ðŸ¤– AI analysis completed for BNB: HOLD (50.0% confidence)
ðŸš€ Executing ai request (priority 4)
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for ETH: $4,144.7
â³ Queued coingecko request (priority 1) - Queue size: 1
âŒ Error saving analysis history: Error [PrismaClientValidationError]: 
Invalid `prisma.analysisHistory.create()` invocation:

{
  data: {
    cryptoId: "solana",
    signal: "HOLD",
    confidence: 0.5,
    reasoning: "Market conditions are neutral",
    riskLevel: "MEDIUM",
    aiModel: "z-ai-web-dev-sdk-v1",
    metricsData: "{\"timestamp\":\"2025-08-20T13:59:42.571Z\",\"analysisType\":\"automated\",\"version\":\"1.0\"}",
+   coinId: String
  }
}

Argument `coinId` is missing.
    at async DataCollector.saveAnalysisHistory (src/lib/data-collector.ts:941:6)
    at async (src/lib/data-collector.ts:775:10)
    at async SmartRateLimiter.executeTask (src/lib/rate-limiter.ts:122:21)
    at async DataCollector.runAIAnalysis (src/lib/data-collector.ts:773:8)
    at async Timeout._onTimeout (src/lib/data-collector.ts:397:6) {
  clientVersion: '6.13.0'
}
ðŸ¤– AI analysis completed for SOL: HOLD (50.0% confidence)
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸš€ Executing coingecko request (priority 1)
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BNB: $823.92
ðŸš€ Executing coingecko request (priority 1)
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for SOL: $179.08
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸ”„ Warming market data cache...
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 97.6%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing coingecko request (priority 1)
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BTC: $112,844
ðŸš€ Executing coingecko request (priority 1)
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸ”„ Warming market data cache...
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for ETH: $4,148.17
â³ Queued coingecko request (priority 1) - Queue size: 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸš€ Executing coingecko request (priority 1)
âŒ Error collecting price data: Error: Task coingecko_1755698675354_0uriz9m6j timed out after 30000ms
    at Timeout._onTimeout (src/lib/rate-limiter.ts:172:15)
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BNB: $824.44
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 94.6%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 92.5%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 91.8%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸ”„ Warming market data cache...
ðŸ”„ Warming crypto metrics cache...
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
âŒ Failed to get crypto metrics for binancecoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for bitcoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for ethereum: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for solana: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âœ… Cache warming completed for 4 keys
âœ… Crypto metrics cache warmed for 4 cryptocurrencies
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸ”„ Running database health check...
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 98.8%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=ethereum&timeframe=24h 200 in 15ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT 1
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT 1
 GET /api/v2/blockchain/cashflow-metrics?blockchain=ethereum&timeframe=24h 200 in 92ms
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=ethereum 200 in 94ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum&timeframe=24h 200 in 376ms
ðŸš€ Initializing Performance Optimization Module...
ðŸš€ Initializing Performance Optimization Service...
âœ… Redis cache connected
âœ… Multi-Layer Caching Strategy initialized
ðŸ”„ Load Testing Service initialized
prisma:info Starting a sqlite pool with 9 connections.
prisma:query 
        SET pool_size = 20;
        SET max_connections = 100;
        SET shared_buffers = '256MB';
        SET effective_cache_size = '1GB';
        SET maintenance_work_mem = '64MB';
        SET checkpoint_completion_target = 0.9;
        SET wal_buffers = '16MB';
        SET default_statistics_target = 100;
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Performance dashboard initialized
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
âš ï¸ Connection pooling setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
    at async DatabaseOptimizationService.setupConnectionPooling (src/lib/performance/database-optimization.ts:92:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:76:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  90 |     try {
  91 |       // Configure connection pool settings
> 92 |       await this.prisma.$executeRaw`
     |      ^
  93 |         SET pool_size = 20;
  94 |         SET max_connections = 100;
  95 |         SET shared_buffers = '256MB'; {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:query 
        SET enable_nestloop = ON;
        SET enable_hashjoin = ON;
        SET enable_mergejoin = ON;
        SET enable_indexscan = ON;
        SET enable_bitmapscan = ON;
        SET effective_io_concurrency = 2;
        SET random_page_cost = 1.1;
        SET seq_page_cost = 1.0;
      
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
âš ï¸ Query optimization setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near "SET": syntax error`
    at async DatabaseOptimizationService.setupQueryOptimization (src/lib/performance/database-optimization.ts:112:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:77:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  110 |     try {
  111 |       // Enable query optimization features
> 112 |       await this.prisma.$executeRaw`
      |      ^
  113 |         SET enable_nestloop = ON;
  114 |         SET enable_hashjoin = ON;
  115 |         SET enable_mergejoin = ON; {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:query 
        CREATE INDEX IF NOT EXISTS idx_crypto_symbol_active 
        ON "main"."cryptocurrencies" (symbol, is_active);
        
        CREATE INDEX IF NOT EXISTS idx_crypto_created_at 
        ON "main"."cryptocurrencies" (created_at);
        
        CREATE INDEX IF NOT EXISTS idx_price_history_crypto_timestamp 
        ON "main"."price_history" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_price_history_timestamp 
        ON "main"."price_history" (timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_onchain_crypto_timestamp 
        ON "main"."on_chain_metrics" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_technical_crypto_timestamp 
        ON "main"."technical_indicators" (crypto_id, timestamp DESC);
        
        CREATE INDEX IF NOT EXISTS idx_sentiment_crypto_timestamp 
        ON "main"."sentiment_data" (crypto_id, timestamp DESC);
      
prisma:error 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near ".": syntax error`
âš ï¸ Index optimization setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$executeRaw()` invocation:


Raw query failed. Code: `1`. Message: `near ".": syntax error`
    at async DatabaseOptimizationService.setupIndexOptimization (src/lib/performance/database-optimization.ts:132:6)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:78:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  130 |     try {
  131 |       // Create performance monitoring indexes if they don't exist
> 132 |       await this.prisma.$executeRaw`
      |      ^
  133 |         CREATE INDEX IF NOT EXISTS idx_crypto_symbol_active 
  134 |         ON "main"."cryptocurrencies" (symbol, is_active);
  135 |          {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:query 
        SELECT * FROM pg_extension WHERE extname = 'pg_partman'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_extension`
âš ï¸ Partitioning setup failed: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_extension`
    at async DatabaseOptimizationService.setupPartitioning (src/lib/performance/database-optimization.ts:164:27)
    at async DatabaseOptimizationService.initialize (src/lib/performance/database-optimization.ts:79:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:233:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  162 |     try {
  163 |       // Check if partitioning extension is available
> 164 |       const partitionExt = await this.prisma.$queryRaw`
      |                           ^
  165 |         SELECT * FROM pg_extension WHERE extname = 'pg_partman'
  166 |       `;
  167 |        {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Database Optimization Service initialized successfully
âœ… Database optimization initialized
âœ… Caching strategy initialized
ðŸ”„ Initializing Cache Warming Service...
ðŸ“… Scheduled warm-market-data every 5 minutes
ðŸ“… Scheduled warm-crypto-metrics every 10 minutes
ðŸ“… Scheduled warm-analysis-data every 15 minutes
ðŸ“… Scheduled warm-sentiment-data every 30 minutes
âœ… Cache warming tasks scheduled
ðŸ”„ Running initial cache warming...
ðŸ”„ Warming market data cache...
ðŸ”„ Warming crypto metrics cache...
ðŸ”„ Warming analysis data cache...
ðŸ”„ Warming sentiment data cache...
âŒ Failed to get sentiment data: TypeError: Cannot read properties of undefined (reading 'findMany')
    at CacheWarmingService.getSentimentData (src/lib/performance/cache-warming.ts:375:51)
    at CacheWarmingService.warmSentimentData (src/lib/performance/cache-warming.ts:237:39)
    at CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:119:13)
    at CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:17)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  373 |   private async getSentimentData(): Promise<any[]> {
  374 |     try {
> 375 |       const sentimentData = await db.sentimentData.findMany({
      |                                                   ^
  376 |         where: {
  377 |           timestamp: {
  378 |             gte: new Date(Date.now() - 6 * 60 * 60 * 1000), // Last 6 hours
âŒ Failed to get crypto metrics for binancecoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for bitcoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for ethereum: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for solana: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async CacheWarmingService.runInitialWarming (src/lib/performance/cache-warming.ts:115:6)
    at async CacheWarmingService.initialize (src/lib/performance/cache-warming.ts:57:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:247:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âœ… Cache warming completed for 4 keys
âœ… Crypto metrics cache warmed for 4 cryptocurrencies
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`analysis_history`.`id`, `main`.`analysis_history`.`cryptoId`, `main`.`analysis_history`.`coinId`, `main`.`analysis_history`.`signal`, `main`.`analysis_history`.`confidence`, `main`.`analysis_history`.`reasoning`, `main`.`analysis_history`.`riskLevel`, `main`.`analysis_history`.`aiModel`, `main`.`analysis_history`.`analysisType`, `main`.`analysis_history`.`analysisData`, `main`.`analysis_history`.`metricsData`, `main`.`analysis_history`.`timestamp` FROM `main`.`analysis_history` WHERE `main`.`analysis_history`.`timestamp` >= ? ORDER BY `main`.`analysis_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
âœ… Initial cache warming completed
âœ… Cache Warming Service initialized successfully
âœ… Cache warming initialized
ðŸ”„ Initializing Performance Monitoring Service...
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.initializeDashboard (src/lib/performance/performance-monitoring.ts:139:18)
    at async PerformanceMonitoringService.initialize (src/lib/performance/performance-monitoring.ts:124:6)
    at async PerformanceOptimizationService.initializeComponents (src/lib/performance/performance-optimization.ts:254:8)
    at async PerformanceOptimizationService.initialize (src/lib/performance/performance-optimization.ts:207:6)
    at async initializePerformanceOptimization (src/lib/performance/index.ts:240:4)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âœ… Performance dashboard initialized
âœ… Metrics collection started
âœ… Performance Monitoring Service initialized successfully
âœ… Performance monitoring initialized
âœ… Load testing initialized
âœ… All components initialized
ðŸ“… Scheduled database-optimization every 60 minutes
ðŸ“… Scheduled database-health-check every 5 minutes
âœ… Cache warming scheduled
âœ… Performance monitoring scheduled
ðŸ“… Scheduled health-check every 5 minutes
âœ… Optimization tasks scheduled
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: HEALTHY
âœ… Performance Optimization Service initialized successfully
âœ… Performance Optimization Module initialized successfully
 GET / 200 in 1079ms
 GET /favicon.ico 200 in 15ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=bitcoin&timeframe=24h 200 in 48ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=bitcoin&timeframe=24h 200 in 119ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE 1=1 ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/enhanced-tvl?coinId=bitcoin&timeframe=24h 200 in 128ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
Error processing blockchain ethereum: TypeError: tvlService.getLatestTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-comparison/route.ts:47:44)
  45 |
  46 |         // Get TVL metrics
> 47 |         const tvlMetrics = await tvlService.getLatestTVLMetrics(crypto.id);
     |                                            ^
  48 |         
  49 |         // Get market data
  50 |         const priceData = await db.priceHistory.findFirst({
 GET /api/v2/blockchain/market-overview?blockchain=bitcoin 200 in 191ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
Error processing blockchain bitcoin: TypeError: tvlService.getLatestTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-comparison/route.ts:47:44)
  45 |
  46 |         // Get TVL metrics
> 47 |         const tvlMetrics = await tvlService.getLatestTVLMetrics(crypto.id);
     |                                            ^
  48 |         
  49 |         // Get market data
  50 |         const priceData = await db.priceHistory.findFirst({
Error processing blockchain solana: TypeError: tvlService.getLatestTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-comparison/route.ts:47:44)
  45 |
  46 |         // Get TVL metrics
> 47 |         const tvlMetrics = await tvlService.getLatestTVLMetrics(crypto.id);
     |                                            ^
  48 |         
  49 |         // Get market data
  50 |         const priceData = await db.priceHistory.findFirst({
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-comparison?blockchains=ethereum,bitcoin,solana,binance-smart-chain,polygon 200 in 332ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/ai-analysis?blockchain=bitcoin 200 in 216ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
 GET /api/v2/blockchain/usage-metrics?blockchain=ethereum&timeframe=24h 200 in 92ms
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/enhanced-tvl?coinId=ethereum&timeframe=24h 200 in 99ms
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE 1=1 ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=ethereum&timeframe=24h 200 in 24ms
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=ethereum 200 in 21ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/ai-analysis?blockchain=ethereum 200 in 26ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=bitcoin&timeframe=24h 200 in 625ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum&timeframe=24h 200 in 463ms
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸš€ Initializing Performance Optimization Module...
âœ… Performance Optimization Module initialized successfully
 GET / 200 in 46ms
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
 GET /favicon.ico 200 in 37ms
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=bitcoin&timeframe=24h 200 in 76ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE 1=1 ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/enhanced-tvl?coinId=bitcoin&timeframe=24h 200 in 34ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=bitcoin 200 in 19ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=bitcoin&timeframe=24h 200 in 27ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/ai-analysis?blockchain=bitcoin 200 in 17ms
Error processing blockchain ethereum: TypeError: tvlService.getLatestTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-comparison/route.ts:47:44)
  45 |
  46 |         // Get TVL metrics
> 47 |         const tvlMetrics = await tvlService.getLatestTVLMetrics(crypto.id);
     |                                            ^
  48 |         
  49 |         // Get market data
  50 |         const priceData = await db.priceHistory.findFirst({
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
Error processing blockchain bitcoin: TypeError: tvlService.getLatestTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-comparison/route.ts:47:44)
  45 |
  46 |         // Get TVL metrics
> 47 |         const tvlMetrics = await tvlService.getLatestTVLMetrics(crypto.id);
     |                                            ^
  48 |         
  49 |         // Get market data
  50 |         const priceData = await db.priceHistory.findFirst({
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
Error processing blockchain solana: TypeError: tvlService.getLatestTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-comparison/route.ts:47:44)
  45 |
  46 |         // Get TVL metrics
> 47 |         const tvlMetrics = await tvlService.getLatestTVLMetrics(crypto.id);
     |                                            ^
  48 |         
  49 |         // Get market data
  50 |         const priceData = await db.priceHistory.findFirst({
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 94.6%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-comparison?blockchains=ethereum,bitcoin,solana,binance-smart-chain,polygon 200 in 472ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/usage-metrics?blockchain=ethereum&timeframe=24h 200 in 306ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`volume_history`.`id`, `main`.`volume_history`.`cryptoId`, `main`.`volume_history`.`timestamp`, `main`.`volume_history`.`dailyVolume`, `main`.`volume_history`.`price`, `main`.`volume_history`.`exchangeVolume`, `main`.`volume_history`.`volumeChange24h`, `main`.`volume_history`.`volumeAvg30d`, `main`.`volume_history`.`volumeVsAvg` FROM `main`.`volume_history` WHERE (`main`.`volume_history`.`cryptoId` = ? AND `main`.`volume_history`.`timestamp` >= ? AND `main`.`volume_history`.`timestamp` < ?) ORDER BY `main`.`volume_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE (`main`.`derivative_metrics`.`cryptoId` = ? AND `main`.`derivative_metrics`.`timestamp` >= ? AND `main`.`derivative_metrics`.`timestamp` < ?) ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE (`main`.`price_history`.`cryptoId` = ? AND `main`.`price_history`.`timestamp` >= ? AND `main`.`price_history`.`timestamp` < ?) ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE (`main`.`on_chain_metrics`.`cryptoId` = ? AND `main`.`on_chain_metrics`.`timestamp` >= ? AND `main`.`on_chain_metrics`.`timestamp` < ?) ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/cashflow-metrics?blockchain=ethereum&timeframe=24h 200 in 77ms
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE `main`.`enhanced_tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`enhanced_tvl_metrics`.`id`, `main`.`enhanced_tvl_metrics`.`cryptoId`, `main`.`enhanced_tvl_metrics`.`timestamp`, `main`.`enhanced_tvl_metrics`.`concentrationRisk`, `main`.`enhanced_tvl_metrics`.`herfindahlIndex`, `main`.`enhanced_tvl_metrics`.`topProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top3ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`top5ProtocolDominance`, `main`.`enhanced_tvl_metrics`.`protocolDiversity`, `main`.`enhanced_tvl_metrics`.`concentrationLevel`, `main`.`enhanced_tvl_metrics`.`concentrationTrend`, `main`.`enhanced_tvl_metrics`.`sustainabilityScore`, `main`.`enhanced_tvl_metrics`.`revenueStability`, `main`.`enhanced_tvl_metrics`.`userGrowthRate`, `main`.`enhanced_tvl_metrics`.`protocolHealth`, `main`.`enhanced_tvl_metrics`.`ecosystemMaturity`, `main`.`enhanced_tvl_metrics`.`riskAdjustedReturns`, `main`.`enhanced_tvl_metrics`.`sustainabilityLevel`, `main`.`enhanced_tvl_metrics`.`sustainabilityTrend`, `main`.`enhanced_tvl_metrics`.`overallTVLHealth`, `main`.`enhanced_tvl_metrics`.`recommendations`, `main`.`enhanced_tvl_metrics`.`riskFactors`, `main`.`enhanced_tvl_metrics`.`strengthFactors`, `main`.`enhanced_tvl_metrics`.`confidence`, `main`.`enhanced_tvl_metrics`.`lastUpdated` FROM `main`.`enhanced_tvl_metrics` WHERE 1=1 ORDER BY `main`.`enhanced_tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/enhanced-tvl?coinId=ethereum&timeframe=24h 200 in 86ms
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`on_chain_metrics`.`id`, `main`.`on_chain_metrics`.`cryptoId`, `main`.`on_chain_metrics`.`timestamp`, `main`.`on_chain_metrics`.`mvrv`, `main`.`on_chain_metrics`.`nupl`, `main`.`on_chain_metrics`.`sopr`, `main`.`on_chain_metrics`.`activeAddresses`, `main`.`on_chain_metrics`.`newAddresses`, `main`.`on_chain_metrics`.`exchangeInflow`, `main`.`on_chain_metrics`.`exchangeOutflow`, `main`.`on_chain_metrics`.`transactionVolume`, `main`.`on_chain_metrics`.`supplyDistribution`, `main`.`on_chain_metrics`.`whaleHoldingsPercentage`, `main`.`on_chain_metrics`.`retailHoldingsPercentage`, `main`.`on_chain_metrics`.`exchangeHoldingsPercentage` FROM `main`.`on_chain_metrics` WHERE `main`.`on_chain_metrics`.`cryptoId` = ? ORDER BY `main`.`on_chain_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`coinGeckoId` = ? LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`sentiment_metrics`.`id`, `main`.`sentiment_metrics`.`timestamp`, `main`.`sentiment_metrics`.`fearGreedIndex`, `main`.`sentiment_metrics`.`socialSentiment`, `main`.`sentiment_metrics`.`googleTrends`, `main`.`sentiment_metrics`.`newsSentiment` FROM `main`.`sentiment_metrics` WHERE 1=1 ORDER BY `main`.`sentiment_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`derivative_metrics`.`id`, `main`.`derivative_metrics`.`cryptoId`, `main`.`derivative_metrics`.`timestamp`, `main`.`derivative_metrics`.`openInterest`, `main`.`derivative_metrics`.`fundingRate`, `main`.`derivative_metrics`.`liquidationVolume`, `main`.`derivative_metrics`.`putCallRatio` FROM `main`.`derivative_metrics` WHERE `main`.`derivative_metrics`.`cryptoId` = ? ORDER BY `main`.`derivative_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`technical_indicators`.`id`, `main`.`technical_indicators`.`cryptoId`, `main`.`technical_indicators`.`timestamp`, `main`.`technical_indicators`.`rsi`, `main`.`technical_indicators`.`ma50`, `main`.`technical_indicators`.`ma200`, `main`.`technical_indicators`.`macd`, `main`.`technical_indicators`.`macdSignal`, `main`.`technical_indicators`.`bollingerUpper`, `main`.`technical_indicators`.`bollingerLower`, `main`.`technical_indicators`.`bollingerMiddle` FROM `main`.`technical_indicators` WHERE `main`.`technical_indicators`.`cryptoId` = ? ORDER BY `main`.`technical_indicators`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`rank` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/market-overview?blockchain=ethereum 200 in 26ms
 GET /api/v2/blockchain/ai-analysis?blockchain=ethereum 200 in 30ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=bitcoin&timeframe=24h 200 in 830ms
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum&timeframe=24h 200 in 399ms
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ CRITICAL Alert: High CPU Usage - CPU usage is 98.1%
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE 1=1 LIMIT ? OFFSET ?
ðŸš€ Executing coingecko request (priority 1)
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BTC: $112,639
ðŸš€ Executing coingecko request (priority 1)
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸ”„ Warming crypto metrics cache...
ðŸ”„ Warming market data cache...
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
âŒ Failed to get crypto metrics for binancecoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for bitcoin: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for ethereum: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âŒ Failed to get crypto metrics for solana: TypeError: Cannot read properties of undefined (reading 'findFirst')
    at CacheWarmingService.getCryptoMetrics (src/lib/performance/cache-warming.ts:322:53)
    at CacheWarmingService.warmCryptoMetrics (src/lib/performance/cache-warming.ts:174:37)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/cache-warming.ts:99:8)
  320 |     try {
  321 |       // Get latest on-chain metrics for the cryptocurrency
> 322 |       const onChainMetrics = await db.onChainMetrics.findFirst({
      |                                                     ^
  323 |         where: {
  324 |           cryptoId,
  325 |         },
âœ… Cache warming completed for 4 keys
âœ… Crypto metrics cache warmed for 4 cryptocurrencies
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
âœ… Cache warming completed for 4 keys
âœ… Market data cache warmed for 4 cryptocurrencies
ðŸ”„ Running database health check...
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async DatabaseOptimizationService.runHealthCheck (src/lib/performance/database-optimization.ts:419:22)
    at async PerformanceOptimizationService.checkDatabaseHealth (src/lib/performance/performance-optimization.ts:364:21)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-optimization.ts:328:8)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
âš ï¸ Database health issues detected: [ 'Low index usage ratio', 'Low cache hit ratio' ]
âœ… Database health check completed
ðŸ”„ Running system health check...
âœ… Component status updated
âœ… System health check completed - Status: CRITICAL
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for ETH: $4,129.37
â³ Queued coingecko request (priority 1) - Queue size: 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum 200 in 376ms
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE (`main`.`cryptocurrencies`.`coinGeckoId` = ? OR `main`.`cryptocurrencies`.`symbol` = ?) LIMIT ? OFFSET ?
prisma:query SELECT `main`.`tvl_metrics`.`id`, `main`.`tvl_metrics`.`cryptoId`, `main`.`tvl_metrics`.`timestamp`, `main`.`tvl_metrics`.`totalTVL`, `main`.`tvl_metrics`.`chainTVL`, `main`.`tvl_metrics`.`tvlChange24h`, `main`.`tvl_metrics`.`tvlChange7d`, `main`.`tvl_metrics`.`tvlChange30d`, `main`.`tvl_metrics`.`dominance`, `main`.`tvl_metrics`.`marketCapTVLRatio`, `main`.`tvl_metrics`.`defiProtocols`, `main`.`tvl_metrics`.`protocolDistribution`, `main`.`tvl_metrics`.`topChainsByTVL`, `main`.`tvl_metrics`.`tvlHistory`, `main`.`tvl_metrics`.`dominanceHistory`, `main`.`tvl_metrics`.`dataSources`, `main`.`tvl_metrics`.`lastUpdated`, `main`.`tvl_metrics`.`confidence` FROM `main`.`tvl_metrics` WHERE `main`.`tvl_metrics`.`cryptoId` = ? ORDER BY `main`.`tvl_metrics`.`timestamp` DESC LIMIT ? OFFSET ?
Error collecting fresh TVL metrics: TypeError: tvlService.collectTVLMetrics is not a function
    at GET (src/app/api/v2/blockchain/tvl-metrics/route.ts:72:38)
  70 |       try {
  71 |         // Collect fresh TVL metrics
> 72 |         tvlMetrics = await tvlService.collectTVLMetrics(crypto.id, crypto.coinGeckoId);
     |                                      ^
  73 |       } catch (error) {
  74 |         console.error('Error collecting fresh TVL metrics:', error);
  75 |         // Continue with existing data if collection fails
prisma:query SELECT `main`.`price_history`.`id`, `main`.`price_history`.`cryptoId`, `main`.`price_history`.`timestamp`, `main`.`price_history`.`price`, `main`.`price_history`.`volume24h`, `main`.`price_history`.`marketCap`, `main`.`price_history`.`priceChange24h` FROM `main`.`price_history` WHERE `main`.`price_history`.`cryptoId` = ? ORDER BY `main`.`price_history`.`timestamp` DESC LIMIT ? OFFSET ?
 GET /api/v2/blockchain/tvl-metrics?blockchain=ethereum 200 in 337ms
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
ðŸš€ Executing coingecko request (priority 1)
âŒ Error collecting price data: Error: Task coingecko_1755698975347_ddn982v67 timed out after 30000ms
    at Timeout._onTimeout (src/lib/rate-limiter.ts:172:15)
prisma:query INSERT INTO `main`.`price_history` (`id`, `cryptoId`, `timestamp`, `price`, `volume24h`, `marketCap`, `priceChange24h`) VALUES (?,?,?,?,?,?,?) RETURNING `id` AS `id`, `cryptoId` AS `cryptoId`, `timestamp` AS `timestamp`, `price` AS `price`, `volume24h` AS `volume24h`, `marketCap` AS `marketCap`, `priceChange24h` AS `priceChange24h`
ðŸ’° Price data collected for BNB: $823.6
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query SELECT 1
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
prisma:query SELECT 1
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_activity
        WHERE state = 'active'
      
prisma:query 
        SELECT 
          (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
        FROM pg_stat_user_tables
      
prisma:query 
        SELECT 
          (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
        FROM pg_statio_user_tables
      
prisma:query SELECT 1
prisma:query 
        SELECT count(*) as count
        FROM pg_stat_statements
        WHERE mean_time > 1000
      
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
âš ï¸ Failed to get active connections: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_activity`
    at async DatabaseOptimizationService.getActiveConnections (src/lib/performance/database-optimization.ts:355:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  353 |   private async getActiveConnections(): Promise<number> {
  354 |     try {
> 355 |       const result = await this.prisma.$queryRaw`
      |                     ^
  356 |         SELECT count(*) as count
  357 |         FROM pg_stat_activity
  358 |         WHERE state = 'active' {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
âš ï¸ Failed to get slow query count: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_statements`
    at async DatabaseOptimizationService.getSlowQueryCount (src/lib/performance/database-optimization.ts:370:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  368 |   private async getSlowQueryCount(): Promise<number> {
  369 |     try {
> 370 |       const result = await this.prisma.$queryRaw`
      |                     ^
  371 |         SELECT count(*) as count
  372 |         FROM pg_stat_statements
  373 |         WHERE mean_time > 1000 {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
âš ï¸ Failed to get index usage: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_stat_user_tables`
    at async DatabaseOptimizationService.getIndexUsage (src/lib/performance/database-optimization.ts:385:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  383 |   private async getIndexUsage(): Promise<number> {
  384 |     try {
> 385 |       const result = await this.prisma.$queryRaw`
      |                     ^
  386 |         SELECT 
  387 |           (sum(idx_scan) * 100.0 / nullif(sum(idx_scan) + sum(seq_scan), 0)) as usage_ratio
  388 |         FROM pg_stat_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
prisma:error 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
âš ï¸ Failed to get cache hit ratio: Error [PrismaClientKnownRequestError]: 
Invalid `prisma.$queryRaw()` invocation:


Raw query failed. Code: `1`. Message: `no such table: pg_statio_user_tables`
    at async DatabaseOptimizationService.getCacheHitRatio (src/lib/performance/database-optimization.ts:400:21)
    at async DatabaseOptimizationService.getPerformanceMetrics (src/lib/performance/database-optimization.ts:327:75)
    at async PerformanceMonitoringService.getDatabaseMetrics (src/lib/performance/performance-monitoring.ts:283:24)
    at async PerformanceMonitoringService.collectAllMetrics (src/lib/performance/performance-monitoring.ts:181:53)
    at async Timeout.eval [as _onTimeout] (src/lib/performance/performance-monitoring.ts:164:10)
  398 |   private async getCacheHitRatio(): Promise<number> {
  399 |     try {
> 400 |       const result = await this.prisma.$queryRaw`
      |                     ^
  401 |         SELECT 
  402 |           (sum(heap_blks_hit) * 100.0 / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0)) as hit_ratio
  403 |         FROM pg_statio_user_tables {
  code: 'P2010',
  meta: [Object],
  clientVersion: '6.13.0'
}
ðŸš¨ WARNING Alert: Low Index Usage - Index usage ratio is 0.0%
ðŸš¨ WARNING Alert: Low Cache Hit Rate - Cache hit rate is 0.0%
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `npx tsx server.ts`[39m
ðŸ”„ Smart Rate Limiter started processing queues
ðŸš€ Initializing AI/ML systems...
Initializing AI/ML anomaly detection system...
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
Starting AI/ML model training...
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? LIMIT ? OFFSET ?
Training models for cryptocurrency bitcoin
Training statistical model for bitcoin
Training correlation model for bitcoin
Training models for cryptocurrency ethereum
Training statistical model for ethereum
Training correlation model for ethereum
Training models for cryptocurrency binancecoin
Training statistical model for binancecoin
Training correlation model for binancecoin
Training models for cryptocurrency solana
Training statistical model for solana
Training correlation model for solana
AI/ML model training completed
AI/ML anomaly detection system initialized successfully
âœ… Anomaly detection system initialized
âœ… Data providers initialized
 â¨¯ uncaughtException: Error: listen EADDRINUSE: address already in use 0.0.0.0:3000
    at <unknown> (Error: listen EADDRINUSE: address already in use 0.0.0.0:3000) {
  code: 'EADDRINUSE',
  errno: -98,
  syscall: 'listen',
  address: '0.0.0.0',
  port: 3000
}
 â¨¯ uncaughtException:  Error: listen EADDRINUSE: address already in use 0.0.0.0:3000
    at <unknown> (Error: listen EADDRINUSE: address already in use 0.0.0.0:3000) {
  code: 'EADDRINUSE',
  errno: -98,
  syscall: 'listen',
  address: '0.0.0.0',
  port: 3000
}
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `npx tsx server.ts`[39m
ðŸ”„ Smart Rate Limiter started processing queues
ðŸš€ Initializing AI/ML systems...
Initializing AI/ML anomaly detection system...
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? ORDER BY `main`.`cryptocurrencies`.`id` ASC LIMIT ? OFFSET ?
Starting AI/ML model training...
prisma:query SELECT `main`.`cryptocurrencies`.`id`, `main`.`cryptocurrencies`.`symbol`, `main`.`cryptocurrencies`.`name`, `main`.`cryptocurrencies`.`coinGeckoId`, `main`.`cryptocurrencies`.`logo`, `main`.`cryptocurrencies`.`rank`, `main`.`cryptocurrencies`.`isActive`, `main`.`cryptocurrencies`.`isDefault`, `main`.`cryptocurrencies`.`addedBy`, `main`.`cryptocurrencies`.`createdAt`, `main`.`cryptocurrencies`.`updatedAt` FROM `main`.`cryptocurrencies` WHERE `main`.`cryptocurrencies`.`isActive` = ? LIMIT ? OFFSET ?
Training models for cryptocurrency bitcoin
Training statistical model for bitcoin
Training correlation model for bitcoin
Training models for cryptocurrency ethereum
Training statistical model for ethereum
Training correlation model for ethereum
Training models for cryptocurrency binancecoin
Training statistical model for binancecoin
Training correlation model for binancecoin
Training models for cryptocurrency solana
Training statistical model for solana
Training correlation model for solana
AI/ML model training completed
AI/ML anomaly detection system initialized successfully
âœ… Anomaly detection system initialized
âœ… Data providers initialized
 â¨¯ uncaughtException: Error: listen EADDRINUSE: address already in use 0.0.0.0:3000
    at <unknown> (Error: listen EADDRINUSE: address already in use 0.0.0.0:3000) {
  code: 'EADDRINUSE',
  errno: -98,
  syscall: 'listen',
  address: '0.0.0.0',
  port: 3000
}
 â¨¯ uncaughtException:  Error: listen EADDRINUSE: address already in use 0.0.0.0:3000
    at <unknown> (Error: listen EADDRINUSE: address already in use 0.0.0.0:3000) {
  code: 'EADDRINUSE',
  errno: -98,
  syscall: 'listen',
  address: '0.0.0.0',
  port: 3000
}
